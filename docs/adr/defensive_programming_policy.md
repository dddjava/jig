# 防御的プログラミングを行わない

## 状況 (Context)

プロジェクトの運用において、コードベースの堅牢性や柔軟性を保ちながらも、複雑さを排除し開発スピードを向上させる必要があります。伝統的な防御的プログラミング（例: nullチェックの徹底や防御的コピーの多用）は、しばしばコードの複雑化や冗長性を引き起こし、ドメインロジックの把握を困難にします。

これに加え、開発チームが一貫したプラクティスを共有することにより、コードメンテナンスのコストを削減し、より堅牢で明瞭な設計を実現することが可能です。そのため、防御的プログラミングを行わないという方針を採用します。

## 決定 (Decision)

以下の方針を採用します。

1. nullチェックを行わない
   - メソッドの引数や戻り値に `null` を許容しない設計を採用します。
   - 必要に応じて `Optional`（または相当する構造）を利用し、`null` 利用の明示を回避します。

2. ミュータブルインスタンスに対する防御的コピーを行わない
   - ミュータブルなクラスの利用を極力避け、イミュータブルな構造を採用します。
   - 必要に応じて、データの不変性を呼び出し元で担保することを前提とします。

3. 呼び出し元の責務を信頼する
   - メソッドの入力が適切であることを信頼し、異常値チェックやエラー回避のための冗長な処理を行いません。

## 根拠・背景 (Rationale)

- **設計の明瞭性**  
  防御的プログラミングは入力値や内部データの検証処理をコード中に散在させることになり、責務の分離を妨げます。これを排除することでコードの読みやすさが向上します。

- **コードの簡潔さ**  
  不要なチェックやコピー操作を排除することで、コードの行数や複雑性が減り、メンテナンス性が高まります。

- **パフォーマンス向上**  
  不要な防御的操作を省くことで、オーバーヘッドを削減します。

## トレードオフ (Trade-Offs)

- **安全性の低下**  
  呼び出し元が不適切な利用を行った場合、エラーが発生しやすくなります。ただし、このリスクを回避する責任は呼び出し側に明示的に委ねます。

- **教育コスト**  
  開発チーム全員がこの方針を理解し実践するまで、ある程度の教育・啓蒙コストがかかる可能性があります。

## 採用ガイドライン・実装例 (Guidelines)

以下は具体的な設計案や実装例です。

### nullチェックしない
以下のような防御的なコードは使用しません。

```java
// 防御的プログラミングの例（推奨しない）
public String getValueOrDefault(String input) {
  if (input == null) {
    return "default";
  }
  return input;
}
```

代わりに、`null` を受け付けない設計・APIを構築します。

```java
// 明確な意図を持つ設計
public record InputData(String value) {
  public InputData {
    Objects.requireNonNull(value, "value cannot be null");
  }
}

var data = new InputData("inputValue"); // 必須の引数を強調
```

### 防御的コピーを行わない
以下のような無駄な防御的コピーは行いません。

```java
// 防御的コピーの例（推奨しない）
public List<String> getItems() {
  return new ArrayList<>(items); // 不必要
}
```

代わりに、ミュータブル状態が不要であることを合意します。

```java
// イミュータブル設計の例
public record Items(List<String> items) { }
```

## 結論 (Consequences)

この方針を採用することにより、コードの責務が明確となり、エラー時の挙動が予測可能になります。一方、呼び出し側での適切な責務の取り扱いが必要となるため、この文化の定着が重要です。