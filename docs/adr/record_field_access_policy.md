# recordクラス内でのレコードコンポーネントにはフィールドアクセスを使用する

## 状況 (Context)
`record`では、自動生成されたアクセサメソッドを利用することでレコードコンポーネントにアクセス可能です。
しかし、同じクラス内でもフィールド直接アクセス (`componentName`) およびアクセサメソッド (`componentName()`) の両方が混在すると、コードの一貫性が損なわれ、意図や慣習が不明確になる可能性があります。

このため、一貫したアクセス方法を採用する方針を決定します。

## 決定 (Decision)
`record`内では、フィールド直接アクセス（`componentName`）を使用してアクセスする形に統一します。
`this.componentName` のように `this.` は不要です。

### 理由
1. **簡潔性の向上**  
   フィールド直接アクセスは、無駄な間接呼び出しを避け、より簡潔で明確なコードが実現できます。

2. **可視性の向上**  
   レコードコンポーネントへのアクセスがフィールドのシンタックスハイライトで判別しやすくなります。 
   `record`はレコードコンポーネントの他にフィールドを持たないこともこれに寄与します。

3. **一貫性の確保**  
   アクセス方法が統一されることで可読性が向上し、実装時の紛れが低下します。

## トレードオフ (Trade-Offs)
以下のトレードオフを考慮します：
1. **設計変更への柔軟性低下**  
アクセサへの依存を避けることで、将来的にロジックをアクセサに追加する際には直接アクセス箇所を変更する必要があります。
ただし、アクセサに振る舞いを持たせるのはコンストラクタと対称性がとれなくなるため避けるべきであり、これを考慮してアクセサ経由にする必要はありません。

## 採用ガイドライン (Guidelines)
以下のルールに従います：
1. **`record`内ではフィールド直接アクセスを使用する**
   - レコードコンポーネントへの参照はすべて `componentName` を使用します。
   - 自動生成されたアクセサメソッド（例: `componentName()`）はクラス外部からの利用に限定します。

2. **アクセサメソッドにロジックを追加しない**
   - 本方針は、アクセサに追加ロジックを含めないという設計前提のもとで成立します。

3. **一貫性に関して**
   - 複数の方法が混在しないように、適度に気を払います。
   - 一括置換や静的解析などでのチェックは行いません。

## 実装例
### 修正前
```java
public String simpleText() {
    // アクセサメソッドを使用
    return jigTypeReference().simpleName() + " " + id().name();
}
```

### 修正後
```java
public String simpleText() {
    // フィールド直接アクセスを使用
    return jigTypeReference.simpleName() + " " + id.name();
}
```

## 結論 (Consequences)
- アクセス方法が統一されることで、コードの簡潔性と一貫性が向上します。
- アクセサメソッドが持つ冗長性が排除され、コードベースがより明確になります。
- 設計変更時のコスト増加リスクは `record` の不変性を利用する設計で対処可能です。

この方針は、`record`特有の性質に依存します。他のクラス設計には影響しません。